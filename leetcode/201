/*
1.使用简单粗暴的方法肯定不行，会超时。比如m=0,n=INT_MAX
2.我这个方法是先把那些范围太大（n-m过大）的直接排除掉，剩下的在一个小范围的数进行计算，
    2.1因为m,n如果横跨两个2的整数幂的话，结果就为0：
      其中2次幂包括：1，2，4，8，16，32，64,...等。只要m和n这个闭区间中含有两个这样的数，结果肯定为0。
      因为2的整数幂次方只有最高为1，其他低位全部为0.最后向&的结果肯定为0.比如在闭区间【4，8】或者【4，9】这两个区间都含有4，8这两个数。
      那么含有两个就一定为0.我先判断如果M这个数只有一个1,并且N也只有一个1组成的。如果两个数相等，那么最后结果就是这个数。
      如果这两个数不相等，那么结果肯定为0；这样就可以排除很大范围的数。
   2.2因为题目要输入的数是连续的数，所以这些数一定在两个不同2幂次方范围之和【2^k,2^(k+1)).左闭右开。这样的话范围就缩小很多了。他们的位数也必须相同，
   剩下的我们直接遍历就可以了。
  */
   
  




int rangeBitwiseAnd(int m, int n) {
        if(m == n||m==0||n==0)
        {
            return m;
        }
        if((m&(m-1)==0)&&(n&(n-1)==0))
            return 0;
        int ans = INT_MAX;
        int sizeM = 0;
        int sizeN = 0;
        int temp = m;
        while(temp >0)
        {
           // cout<<temp<<endl;
            temp >>= 1;
            sizeM ++;
            
        }
        temp = n;
        while(temp>0)
        {
            temp >>= 1;
            sizeN++;
        }
        if(sizeM!=sizeN)
            return 0;
        for(int i=m;i<=n;i++)
        {
                ans &=i;
            if(i == INT_MAX)
                break;
        }
        return ans;
    }
