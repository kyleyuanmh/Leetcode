//方法1：最简单粗暴的方案，就是直接把中序遍历方式放在数组里，然后进行检查是不是递增的即可.可是效率不太好
/*

执行用时 :
24 ms, 在所有 C++ 提交中击败了54.46%的用户
内存消耗 :
20.8 MB, 在所有 C++ 提交中击败了32.36%的用户

*/


bool isValidBST(TreeNode* root) {
        vector<int> treeNum;
        stack<TreeNode*>st;
        TreeNode* p=root;
        if(p==nullptr)
        {
            return true;
        }
        while(p!=nullptr||!st.empty())
        {
            if(p!=nullptr)
            {
                st.push(p);
                p=p->left;
            }
            else{
                p = st.top();
                st.pop();
                treeNum.push_back(p->val);
                p=p->right;
            }
        }
        for(int i=0;i<treeNum.size()-1;i++)
        {
            if(treeNum[i]>=treeNum[i+1])
                return false;
        }
        return true;
    }
    
//方法2：  dfs深度优先
/*
    
执行用时 :
24 ms, 在所有 C++ 提交中击败了54.17%的用户
内存消耗 :
20.5 MB, 在所有 C++ 提交中击败了70.90%的用户
    
*/
    bool dfs(TreeNode* root,long left,long right)
    {
        if(root==nullptr)
            return true;
        if(root->val<=left||root->val>=right) 
            return false;
        else
            return dfs(root->left,left,root->val)&&dfs(root->right,root->val,right);
    }
    bool isValidBST(TreeNode* root) {
        if(root==nullptr||(root->left==nullptr&&root->right==nullptr))
            return true;
        return dfs(root,LONG_MIN,LONG_MAX);
    }
    
    
    
    
    
    
