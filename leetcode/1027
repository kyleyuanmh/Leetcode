//方法一：暴力解决法时间复杂度O(n^3)不太好.容易超时
//听说这是一道谷歌面试题，呵呵😑

int longestArithSeqLength(vector<int>& A) {
        int size = A.size();
        if(size<=1)
            return size;
        int ans = 0;
        unordered_map<int,int> count;//次数-前后差
        
        for(int k=0;k<size-1;k++)
        {
            int step=0;
            int i=k;
            int j=k+1;
            while(i<size-1)
            {
                step++;
                i = k;
                j = i + step;
                int diff = A[i]-A[j];
                //cout<<"step"<<step<<"  "<<i<<"  "<<j<<endl;
                int num = 0;
                while(j<size && i<size)
                { 
                    if((A[i]-A[j]) == diff)
                    {
                        num++;
                        i = j;
                        j = j+1;
                        
                    }
                    else
                    {
                        j++;
                    }
                    //cout<<i<<"  "<<j<<"  diff:"<<diff<<";num:"<<num<<endl;
                }
                
                if(count.find(diff)==count.end())
                {
                    count.insert(make_pair(diff,num));
                }
                else
                {
                    auto ite = count.find(diff);
                    if(num>(*ite).second)
                    {
                        (*ite).second = num;
                    }
                }
            }
        }
        
        for(auto ite = count.begin();ite!=count.end();ite++){
            //cout<<(*ite).first<<"  :  "<<(*ite).second<<endl;
            if((*ite).second > ans){
                ans = (*ite).second;
            }
        }
        return ans+1;
    }
    
    
    //方法2：动态规划
    class Solution {
public:
    int longestArithSeqLength(vector<int>& A) {
        int n = A.size(), ans = 0;
        vector<unordered_map<int, int>> f(n);
        for (int i = 1; i < n; i++)
            for (int j = 0; j < i; j++) {
                int s = A[j] - A[i];
                if (f[j].find(s) == f[j].end()) {
                    f[i][s] = 1;
                } else {
                    f[i][s] = f[j][s] + 1;
                }
                ans = max(ans, f[i][s]);
            }
        return ans + 1;
    }
};
    
    
    
    
    
