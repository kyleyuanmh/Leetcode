//方法一：暴力解决法时间复杂度O(n^3)不太好.容易超时
//听说这是一道谷歌面试题，呵呵😑

int longestArithSeqLength(vector<int>& A) {
        int size = A.size();
        if(size<=1)
            return size;
        int ans = 0;
        unordered_map<int,int> count;//次数-前后差
        
        for(int k=0;k<size-1;k++)
        {
            int step=0;
            int i=k;
            int j=k+1;
            while(i<size-1)
            {
                step++;
                i = k;
                j = i + step;
                int diff = A[i]-A[j];
                //cout<<"step"<<step<<"  "<<i<<"  "<<j<<endl;
                int num = 0;
                while(j<size && i<size)
                { 
                    if((A[i]-A[j]) == diff)
                    {
                        num++;
                        i = j;
                        j = j+1;
                        
                    }
                    else
                    {
                        j++;
                    }
                    //cout<<i<<"  "<<j<<"  diff:"<<diff<<";num:"<<num<<endl;
                }
                
                if(count.find(diff)==count.end())
                {
                    count.insert(make_pair(diff,num));
                }
                else
                {
                    auto ite = count.find(diff);
                    if(num>(*ite).second)
                    {
                        (*ite).second = num;
                    }
                }
            }
        }
        
        for(auto ite = count.begin();ite!=count.end();ite++){
            //cout<<(*ite).first<<"  :  "<<(*ite).second<<endl;
            if((*ite).second > ans){
                ans = (*ite).second;
            }
        }
        return ans+1;
    }
    
    
//方法2：动态规划
//https://www.acwing.com/solution/LeetCode/content/1559/
/*
(动态规划) O(n2)O(n2)
f(i,j)f(i,j) 表示以 ii 结尾的子序列，差为 jj 时的最长子序列长度。
对任何 xx，f(i,x)=1f(i,x)=1 为初始状态。每次循环枚举 j<i。j<i，计算 s=a[j]−a[i] s=a[j]−a[i]，转移 f(i,s)=f(j,s)+1f(i,s)=f(j,s)+1。
答案为 ff 数组中的最大值。
状态数为为 O(n)O(n) 个，每次转移需要 O(n)O(n) 的时间，故总时间复杂度为 O(n2)O(n2)。
*/
    class Solution {
public:
    int longestArithSeqLength(vector<int>& A) {
        int n = A.size(), ans = 0;
        vector<unordered_map<int, int>> f(n);
        for (int i = 1; i < n; i++)
            for (int j = 0; j < i; j++) {
                int s = A[j] - A[i];
                if (f[j].find(s) == f[j].end()) {
                    f[i][s] = 1;
                } else {
                    f[i][s] = f[j][s] + 1;  //说明从(j之前->j)和（j->i）的差值相同，因此需要链接起来，这样0-i所有等差相同的就可以加起来。
                }
                ans = max(ans, f[i][s]);
            }
        return ans + 1;
    }
};
    
    
    
    
    
