/*
方法一：通过暴力遍历计算任意两个数异或和（异或值1的个数就是两个数的海明距离）
刚开始我就是使用x&(x-1)的方法来一个一个消掉任意两个数的异或值来计算两个数的不同个数。然后主函数进行嵌套循环，发现超时，不行所以必须要走另外一条道。
时间复杂度O(n^2)



方法二：（可以称得上是分治法）
原理就是：
  设置一个掩码mask，这个掩码从1->(1<<31),用掩码来跟数组中的所有数进行&运算，这样根据这一位为0或者为1将数据分成两组。记下这一位不同的两组数目.
假如为p,q.那么这一位中所有数之间的海明距离就是：p*q.然后两组数目清零，掩码mask继续左移，然后在进行把原来的数据分成两份，然后两组数的数目乘积就是这一位
的海明距离之和。依次类推。

时间复杂度O(32n)=O(n)

*/



int totalHammingDistance(vector<int>& nums) {
        int diff[2]={0,0};
        int mask = 1;
        int ans = 0;
        int i=0;
        for(int i=0;i<31;i++)
        {
            diff[0]=0;
            diff[1]=0;
            mask = (1<<i); 
            for(int j = 0;j<nums.size();j++)
            {
                if((mask & nums[j])==0){
                    diff[0]++;
                }else{
                    diff[1]++;
                }
            }
            ans += (diff[0]*diff[1]);
        }
        return ans;
    }
