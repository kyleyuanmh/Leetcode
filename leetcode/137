/*
参考discuss,这方方法简直逆天了。
通过对所有数的0-31比特的检查，把所有数的第i位比特都进行相加：
  如果这一位比特为1的个数是3的倍数，那么这个特殊的数这一位肯定是0，
  如果这一位比特为1的总数之和不是3的倍数，而是3的倍数+1，那么我们要找的特殊的数这一位肯定是1.
我们这样把这个数的每一位是1的数分别或上1向左移动的次数，这样每次都会把这个数的1的位置放在对应的位置上。这样这个数在遍历32遍之后就得到。

时间复杂度O(32n)
空间复杂度O(1)


*/




int singleNumber(vector<int>& nums) {
        int sum = 0;
        int ans = 0;
        for(int i=0;i<32;i++)
        {
            for(int j =0;j<nums.size();j++)
            {
                if((1&(nums[j]>>i)) ==1)
                    sum ++;
            }
            if(sum % 3 !=0)
            {
                ans |= (1<<i);
            }
            sum = 0;
        }
        return ans;
    }
