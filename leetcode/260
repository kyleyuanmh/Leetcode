/*
位运算总能给人带来惊喜：
  1、
    x&(-x)==x最右一位为1的数    //可以通过这个方法得到这个数的最小一位1在什么位置
  2、
    x&(x-1)==x去掉最右一位1的数     //例如111->110     10101->10100

这两种方法能够解决很多问题：
  其中这一题就使用了1.解决该题主要有以下步骤：
  
  （1）因为题目说了有两个只存在一次的数（假如是a，b），所以我们使用遍历所有数组：  ans^nums[i]    得到的是这两个只存在一次的数的异或(a^b)，根据异或
  的概念，两个数相同异或为1，相同异或为0.那么这个得到的结果中出现的为1的都是两个不同的，为0的是二者相同的数，因此我们需要把他们相同的分开就行了。
  （2）根据（1）我们知道a^b中为1的是a,b不一样的位数。我们使用   x&(-x)==x最右一位为1的数   就完全可以找到一个二者不一样所存在的地方，然后根据这一位
  进行分成两部分。res[0],res[1].这一位为0的我们把它分到res[0]中，这一位为1的我们把它分到res[1]中。这样两组数只要相互异或就把原来问题转化为一个数组
  只有一个数存在一次，其他数都存在两次的情况了。
  我们不关心a,b之外其他数会被分到什么地方，只要把他们分开我们目的就达到了。因为除了a,b其他都是出现两次，不管分到什么阵列里面要么没有，要么就两次，
所以他们异或之后还是为0，不影响。





*/




vector<int> singleNumber(vector<int>& nums) {
        vector<int> ans;
        if(nums.size()==2)
        {
            ans.push_back(nums[0]);
            ans.push_back(nums[1]);
            return ans;
        }
        int res = 0;
        for(int i=0;i<nums.size();i++)
        {
            res ^= nums[i];     //得到两个数的异或值
        }
        ans.push_back(0);
        ans.push_back(0);
        res &= -res;              //根据该公式得到res中最低位为1的位置。为1说明二者起码在这一位上是不同的。根据这一位把原来数组分成两组数
        for(int i=0;i<nums.size();i++)
        {
            if((nums[i] & res) == 0)
            {
                ans[0] ^= nums[i];        //这一位为0的分到ans[0]
            }else
            {
                ans[1] ^= nums[i];        //为1的分到ans[1]中   
            }
        }
        return ans;
    }
